<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wasi Shorts — Scroll Player</title>
  <style>
    /* Full-page minimal UI, dark background */
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      background:#000;
      color:#fff;
      overflow:hidden;
      font-family:system-ui,Segoe UI,Roboto,Arial;
    }

    /* iframe fills screen */
    #player {
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      border:0;
      background:#000;
      z-index:1;
    }

    /* overlay captures wheel/touch events so iframe doesn't swallow them */
    #overlay {
      position:fixed;
      inset:0;
      z-index:2;
      background:transparent;
      touch-action:pan-y;
    }

    /* small top hint (fades away) */
    #hint {
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:18px;
      background:rgba(255,255,255,0.06);
      color:#ddd;
      padding:8px 12px;
      border-radius:999px;
      font-size:13px;
      z-index:3;
      backdrop-filter:blur(4px);
    }

    /* tiny re-enable button (shown when overlay hidden) */
    #reEnableBtn {
      position:fixed;
      left:12px;
      top:12px;
      z-index:5;
      background:rgba(0,0,0,0.6);
      color:#fff;
      border:1px solid rgba(255,255,255,0.06);
      padding:6px 8px;
      border-radius:8px;
      font-size:13px;
      cursor:pointer;
      display:none;
    }

    /* loader while fetching */
    #loader {
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:4;
      font-size:16px;
      color:#fff;
      background:linear-gradient(0deg, rgba(0,0,0,0.55), rgba(0,0,0,0.35));
    }
  </style>
</head>
<body>
  <div id="loader">Loading shorts…</div>
  <iframe id="player" src="" allow="autoplay; encrypted-media; picture-in-picture" allowfullscreen></iframe>

  <!-- overlay captures wheel/touch events -->
  <div id="overlay" title="Scroll / Swipe to change video"></div>

  <!-- hint -->
  <div id="hint">Scroll or swipe ▲▼ to change • Double-click to interact with video • Press R to return to scroll mode</div>

  <button id="reEnableBtn">Resume scroll (R)</button>

  <script>
    // ====== CONFIG ======
    const apiKey = "AIzaSyCJ5f3o71_PJcI3q4NrdrtC7s9F2iVQVBw"; // your key (you gave this earlier)
    const SEARCH_QUERY = "Pakistani Indian song #shorts";
    const PAGE_SIZE = 20; // how many items to fetch per page
    const DEBOUNCE_MS = 650;

    // ====== STATE ======
    let videos = [];            // array of videoIds
    let currentIndex = 0;
    let nextPageToken = null;   // for pagination
    let isMuted = true;         // start muted so autoplay works
    let interactionMode = false; // when true, overlay won't capture events and iframe controls=1
    let lastAction = 0;

    // DOM
    const player = document.getElementById("player");
    const overlay = document.getElementById("overlay");
    const loader = document.getElementById("loader");
    const hint = document.getElementById("hint");
    const reEnableBtn = document.getElementById("reEnableBtn");

    // hide hint after a short time
    setTimeout(()=>{ hint.style.transition = "opacity 0.6s"; hint.style.opacity = 0; }, 3700);
    setTimeout(()=>{ hint.style.display = "none"; }, 4300);

    // ====== Helpers ======
    function setPlayerSrc(videoId){
      // controls depends on interactionMode
      const controls = interactionMode ? 1 : 0;
      const mute = isMuted ? 1 : 0;
      // enablejsapi=1 allows future advanced control if needed
      player.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&playsinline=1&mute=${mute}&controls=${controls}&rel=0&modestbranding=1&enablejsapi=1`;
    }

    function showVideo(index){
      if(index < 0 || index >= videos.length) return;
      currentIndex = index;
      setPlayerSrc(videos[index]);
    }

    async function fetchShorts(pageToken = null){
      loader.style.display = "flex";
      try {
        let url = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&videoDuration=short&maxResults=${PAGE_SIZE}&q=${encodeURIComponent(SEARCH_QUERY)}&key=${apiKey}`;
        if(pageToken) url += `&pageToken=${pageToken}`;
        const res = await fetch(url);
        const data = await res.json();
        loader.style.display = "none";

        if(!data || !data.items) {
          console.error("YouTube API: invalid response", data);
          return;
        }
        // append new videoIds (avoid undefined ids)
        const ids = data.items.map(it => it?.id?.videoId).filter(Boolean);
        // only keep unique ids
        const newIds = ids.filter(id => !videos.includes(id));
        videos = videos.concat(newIds);
        nextPageToken = data.nextPageToken || null;

        if(videos.length > 0 && player.src === "") showVideo(0);
      } catch(err){
        loader.style.display = "none";
        console.error("Failed fetching shorts:", err);
        alert("Error loading videos. Check console for details.");
      }
    }

    // load initial batch
    fetchShorts();

    // ====== Navigation logic (debounced) ======
    function canAct(){
      if(Date.now() - lastAction < DEBOUNCE_MS) return false;
      lastAction = Date.now();
      return true;
    }

    function nextVideo(){
      if(!canAct()) return;
      if(currentIndex < videos.length - 1){
        showVideo(currentIndex + 1);
      } else if(nextPageToken){
        // fetch more and then advance
        fetchShorts(nextPageToken).then(()=>{
          if(currentIndex < videos.length - 1) showVideo(currentIndex + 1);
        });
      } else {
        // try to fetch next page even if token null (last attempt)
        fetchShorts().then(()=>{
          if(currentIndex < videos.length - 1) showVideo(currentIndex + 1);
        });
      }
    }

    function prevVideo(){
      if(!canAct()) return;
      if(currentIndex > 0) showVideo(currentIndex - 1);
    }

    // ====== Overlay event handlers (captures wheel & touch) ======
    overlay.addEventListener('wheel', e => {
      e.preventDefault();
      if(interactionMode) return;
      if(e.deltaY > 0) nextVideo();
      else prevVideo();
    }, {passive: false});

    // touch for mobile swipe
    let touchStartY = 0;
    overlay.addEventListener('touchstart', e => {
      if(interactionMode) return;
      touchStartY = e.touches[0].clientY;
    }, {passive: true});
    overlay.addEventListener('touchend', e => {
      if(interactionMode) return;
      const endY = e.changedTouches[0].clientY;
      const diff = touchStartY - endY;
      if(Math.abs(diff) < 40) return;
      if(diff > 0) nextVideo(); else prevVideo();
    }, {passive: true});

    // keyboard arrows
    window.addEventListener('keydown', e => {
      if(e.key === 'ArrowDown') nextVideo();
      if(e.key === 'ArrowUp') prevVideo();
      if(e.key === 'r' || e.key === 'R'){ // resume scroll mode
        setInteractionMode(false);
      }
    });

    // double-click overlay => toggle interaction mode (so user can click/unmute)
    overlay.addEventListener('dblclick', () => {
      setInteractionMode(!interactionMode);
    });

    // re-enable button (shown when overlay hidden)
    reEnableBtn.addEventListener('click', ()=> setInteractionMode(false));

    function setInteractionMode(on){
      interactionMode = !!on;
      // update overlay pointer-events: when interactionMode==true we hide overlay so iframe receives events
      if(interactionMode){
        overlay.style.display = 'none';
        reEnableBtn.style.display = 'block';
      } else {
        overlay.style.display = 'block';
        reEnableBtn.style.display = 'none';
      }
      // reload current video with controls enabled/disabled accordingly
      if(videos.length > 0) showVideo(currentIndex);
    }

    // Double-tap (mobile) to toggle interaction
    let lastTap = 0;
    overlay.addEventListener('touchend', (e) => {
      const now = Date.now();
      if(now - lastTap < 300){
        setInteractionMode(!interactionMode);
        lastTap = 0;
      } else lastTap = now;
    });

    // when near end of list, prefetch more
    setInterval(()=>{
      if(videos.length - currentIndex < 6 && nextPageToken){
        fetchShorts(nextPageToken);
      }
    }, 2500);

    // small safety: if iframe reloads slowly, ensure autoplay mute param used
    // (already handled in setPlayerSrc)

    // ============ End ============
  </script>
</body>
</html>
